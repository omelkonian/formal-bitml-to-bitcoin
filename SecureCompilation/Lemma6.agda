-- {-# OPTIONS --allow-unsolved-metas #-}
open import Prelude.Init
open import Prelude.Lists
open import Prelude.DecEq
open import Prelude.Traces
open import Prelude.Membership
open import Prelude.ToN
open import Prelude.General
open import Prelude.ToList
open import Prelude.Sets hiding (toList)
open import Prelude.Functor

open import Bitcoin using (KeyPair)

module SecureCompilation.Lemma6
  (Participant : Set)
  â¦ƒ _ : DecEq Participant â¦„
  (Honest : Listâº Participant)

  (finPart : Finite Participant)
  (keypairs : âˆ€ (A : Participant) â†’ KeyPair Ã— KeyPair)

  (Î· : â„•) -- security parameter
  where

open import SymbolicModel Participant Honest as S
  hiding (d)
open import ComputationalModel Participant Honest finPart keypairs as C
open import SecureCompilation.Compiler Participant Honest Î·
open import SecureCompilation.Coherence Participant Honest finPart keypairs Î·

-- âˆƒdeposit : Blockchain â†’ â„ RË¢ â†’ RË¢ â‰ˆâ‹¯ âŸ¨ c , v âŸ©at x â‹¯ â†’ Set
-- âˆƒdeposit {RË¢}{c}{v} ğ•“ ğ•£ câˆˆ =
--     -- There exists a transaction output (T, o)...
--   âˆƒ Î» (txi : TxInputâ€²) â†’ let (_ , _ , T) at o = txi; Tâ‚’ = T â™¯ at toâ„• o in
--         -- ...unspent in ğ•“...
--         (Tâ‚’ âˆˆË¢ UTXO ğ•“)
--         -- ...with value v.
--       Ã— ((T â€¼áµ’ o) .projâ‚‚ .value â‰¡ v)
--         -- Further, T is generated by...
--       Ã— let
--           Î“â‚œ = RË¢ .end
--           âŸ¨GâŸ©C , _ , adâˆˆ , câŠ† , anc = ANCESTOR {RË¢}{c = c} {Î“ = Î“â‚œ .cfg} (â‰ˆáµ—-refl {Î“â‚œ}) câˆˆ

--           K : ğ•‚ (âŸ¨GâŸ©C .G)
--           K {p} _ = KÌ‚ p

--           vad , txout , sechash , Îº = LIFTá¶œ ğ•£ anc
--           -- ...invoking the compiler as...
--           Tâ‚€ , ğ•” = bitml-compiler {ad = âŸ¨GâŸ©C} vad sechash txout K Îº
--         in
--           -- ...the initial transaction...
--           (T â™¯ â‰¡ Tâ‚€ .projâ‚‚ â™¯)
--           -- ...or retrieving the transaction for a specific subterm.
--         âŠ âˆƒ Î» (eq : length c â‰¡ V.length (T .outputs)) â†’
--           let
--             i : Index c
--             i = âŸª Fin âŸ« eq ~: o

--             open âˆ£SELECT c i

--             âˆƒtx : âˆƒTxá¶œ dâˆ—
--             âˆƒtx = ğ•” $ h-subá¶œ {ds = âŸ¨GâŸ©C .C} $ câŠ† (L.Mem.âˆˆ-lookup i)
--           in
--             T â™¯ â‰¡ âˆƒtx .projâ‚‚ â™¯

open import Prelude.InferenceRules
open import Prelude.Sets

record _âˆ™Value (A : Set) : Set where
  field _âˆ™value : A â†’ C.Value
open _âˆ™Value â¦ƒ...â¦„ public
instance
  TxOutputâˆ™Value : TxOutput ctx âˆ™Value
  TxOutputâˆ™Value ._âˆ™value = value

  âˆƒTxOutputâˆ™Value : âˆƒTxOutput âˆ™Value
  âˆƒTxOutputâˆ™Value ._âˆ™value (_ , txo) = txo âˆ™value

  TxInputâ€²âˆ™Value : TxInputâ€² âˆ™Value
  TxInputâ€²âˆ™Value ._âˆ™value ((_ , _ , T) at o) = (T â€¼áµ’ o) âˆ™value

_âˆ™txoutC_ : (ğ•£ : â„ RË¢) â†’ RË¢ â‰ˆâ‹¯ âŸ¨ c , v âŸ©at x â‹¯ â†’ TxInputâ€²
_âˆ™txoutC_ {R} ğ•£ = ğ•£ .â„.txoutâ€² âˆ˜ namesÊ³â¦…endâ¦†âŠ† R âˆ˜ câˆˆâ‡’xâˆˆ {Î“ = R .end .cfg}

txout-preserves-value :
    (R~ : RË¢ ~ Rá¶œ) â†’ let ğ•£ = R~ .projâ‚ in
    (câˆˆ : RË¢ â‰ˆâ‹¯ âŸ¨ c , v âŸ©at x â‹¯)
    --â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  â†’ (ğ•£ âˆ™txoutC câˆˆ) âˆ™value â‰¡ v

-- * base
txout-preserves-value (ğ•£ , base init Râ‰ˆ cinit txoutâ‰¡ sechashâˆ… Îºâˆ…) câˆˆ
  = âŠ¥-elim $ Initialâ‡’âˆ‰ init $ câˆˆ :~ Râ‰ˆ âŸª (Î» â—† â†’ _ âˆˆá¶œ â—† .end .cfg) âŸ«

-- * inductive case 1
txout-preserves-value (_ , stepâ‚ {âˆƒğ•£@(RË¢ , ğ•£)}{Î“â‚œ}{Rá¶œ}{Î»á¶œ}{ğ•’}{ğ•£â€²} R~ coh) câˆˆ
  -- = ?
  with coh
... | [L] ([1]  Râ‰ˆ âˆƒÎ“â‰ˆ vad hon dâŠ†) = {!!}
... | [L] ([2]  Râ‰ˆ âˆƒÎ“â‰ˆ asâ‰¡ Allâˆ‰ Honâ‡’ âˆƒB hâ‰¡ hâˆˆO unique-h hâ™¯sechash) = ?
... | [L] ([3]  Râ‰ˆ âˆƒÎ“â‰ˆ committedA Aâˆˆper âˆƒB) = ?
... | [L] ([4]  Râ‰ˆ âˆƒÎ“â‰ˆ fresh-z) = ?
... | [L] ([5]  dâ‰¡ Râ‰ˆ âˆƒÎ“â‰ˆ) = ?
{-
... | [L] ([6]  tâ‰¡ dâ‰¡ Râ‰ˆ âˆƒÎ“â‰ˆ fresh-yâ€² pâŸ¦Î”âŸ§â‰¡ Asâ‰¡âˆ…) = ?
... | [L] ([7]  Râ‰ˆ âˆƒÎ“â‰ˆ fresh-ys âˆƒB âˆƒÎ± aâˆˆ âˆƒÎ» first-Î»á¶œ) = ?
... | [L] ([8]  tâ‰¡ dâ‰¡ Râ‰ˆ fresh-xs Asâ‰¡âˆ… âˆƒÎ“â‰ˆ) = ?
... | [L] ([9]  dâ‰¡ Râ‰ˆ âˆƒÎ“â‰ˆ frsg-x Asâ‰¡âˆ… âˆ€â‰¤t) = ?
... | [L] ([10] Râ‰ˆ âˆƒÎ“â‰ˆ âˆƒÎ») = ?
... | [L] ([11] Râ‰ˆ âˆƒÎ“â‰ˆ fresh-y) = ?
... | [L] ([12] Râ‰ˆ âˆƒÎ“â‰ˆ âˆƒÎ» first-Î»á¶œ) = ?
... | [L] ([13] Râ‰ˆ âˆƒÎ“â‰ˆ fresh-ys) = ?
... | [L] ([14] Râ‰ˆ âˆƒÎ“â‰ˆ âˆƒÎ» first-Î»á¶œ) = ?
... | [L] ([15] Râ‰ˆ âˆƒÎ“â‰ˆ fresh-y) = ?
-}
... | [R] ([16] Râ‰ˆ âˆƒÎ“â‰ˆ fresh-y T âŠ†ins Tâˆˆ first-Î»á¶œ Â¬coh) = ?
... | [R] ([17] Râ‰ˆ âˆƒÎ“â‰ˆ T âŠ†ins Â¬coh) = ?
... | [L] ([18] Î´>0 âˆƒÎ“â‰ˆ) = ?

-- * inductive case 2
txout-preserves-value (ğ•£ , stepâ‚‚ R~ _)
  = txout-preserves-value (ğ•£ , R~)

-- _âˆˆáµ¤â‚œâ‚“â‚’_ : TxInputâ€² â†’ Blockchain â†’ Set
-- txi âˆˆáµ¤â‚œâ‚“â‚’ b = hashTxâ± txi âˆˆË¢ UTXO b

-- lemma6 :
--     (R~ : RË¢ ~ Rá¶œ) â†’ let ğ•£ = R~ .projâ‚ in
--     (câˆˆ : RË¢ â‰ˆâ‹¯ âŸ¨ c , v âŸ©at x â‹¯)
--     --â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
--   â†’ (ğ•£ âˆ™txoutC câˆˆ) âˆˆáµ¤â‚œâ‚“â‚’ ğ”¹ Rá¶œ

-- lemma6 (ğ•£ , base init Râ‰ˆ cinit txoutâ‰¡ sechashâˆ… Îºâˆ…) câˆˆ
--   = âŠ¥-elim
--   $ Initialâ‡’âˆ‰ init
--   $ câˆˆ :~ Râ‰ˆ âŸª (Î» â—† â†’ _ âˆˆá¶œ â—† .end .cfg) âŸ«

-- lemma6 (_ , stepâ‚ {âˆƒğ•£@(RË¢ , ğ•£)}{Î“â‚œ}{Rá¶œ}{Î»á¶œ}{ğ•’}{ğ•£â€²} R~ coh) câˆˆ
--   = {!!}

-- -- lemma6 {v = v} {x = x} {c = c} (ğ•£ , stepâ‚‚ {Î»á¶œ} R~ coh) câˆˆ
-- --   = let txi@((_ , _ , T) at o) , Tâˆˆ , â‰¡v , Tâ™¯â‰¡ = lemma6 (ğ•£ , R~) câˆˆ
-- --     in  txi , {!âˆˆ-âˆªâºË¡ (T â™¯ at o) (UTXO txs â”€ STXOâ‚œâ‚“ tx) (UTXOâ‚œâ‚“ tx) !} , â‰¡v , Tâ™¯â‰¡
-- -- lemma6 {RË¢}{Rá¶œ = ğ•“@(.(submit T) âˆ· ls)} {c = c} {v = v} {x = x}
-- --        (ğ•£@(record{ txoutâ€² = txout}) , stepâ‚‚ {Î»á¶œ = .(submit T)} R~ ([1] {T = T} insâ™¯)) câˆˆ
-- --   = let txi@((_ , _ , Tâ€²) at o) = ğ•£ âˆ™txoutC câˆˆ
-- --         Tâˆˆâ€² , â‰¡v , Tâ™¯â‰¡ = lemma6 (ğ•£ , R~) câˆˆ
-- --         Tâ‚’â€² = Tâ€² â™¯ at toâ„• o

-- --         Tâˆ‰ : Tâ‚’â€² âˆ‰Ë¢ STXOâ‚œâ‚“ T
-- --         Tâˆ‰ xâˆˆ =
-- --           let
-- --             xâˆˆâ€² : Tâ‚’â€² âˆˆ V.toList (T .projâ‚‚ .projâ‚‚ .inputs)
-- --             xâˆˆâ€² = âˆˆË¢-fromListâ» xâˆˆ

-- --             Î“âˆˆ : âŸ¨ c , v âŸ©at x âˆˆ allCfgs RË¢
-- --             Î“âˆˆ = {!!}

-- --             txiâ€² : TxInputâ€²
-- --             txiâ€² = Txoutâˆˆ txout {! endâˆˆallCfgsáµ— !} (here refl)

-- --             Tâ‚’âˆˆ : Tâ‚’â€² âˆˆ (hashTxâ± <$> codom txout)
-- --             Tâ‚’âˆˆ = {!!}
-- --           in
-- --             insâ™¯ (xâˆˆâ€² , Tâ‚’âˆˆ)

-- --         Tâˆˆ : Tâ‚’â€² âˆˆË¢ UTXO (ğ”¹ ğ•“)
-- --         Tâˆˆ = âˆˆ-âˆªâºË¡ Tâ‚’â€² (UTXO (ğ”¹ ls) â”€ STXOâ‚œâ‚“ T)
-- --                        (UTXOâ‚œâ‚“ T)
-- --                        (âˆˆ-â”€âº _ (UTXO $ ğ”¹ ls) (STXOâ‚œâ‚“ T) Tâˆˆâ€² Tâˆ‰)
-- --     in  txi , Tâˆˆ , â‰¡v , Tâ™¯â‰¡


-- -- lemma6 (ğ•£ , stepâ‚‚ {Î»á¶œ = .(A â†’Oâˆ¶ m)}  R~ ([2] {A = A}{m} (injâ‚ refl))) câˆˆ = lemma6 (ğ•£ , R~) câˆˆ
-- -- lemma6 (ğ•£ , stepâ‚‚ {Î»á¶œ = .(Oâ†’ A âˆ¶ m)} R~ ([2] {A = A}{m} (injâ‚‚ refl))) câˆˆ = lemma6 (ğ•£ , R~) câˆˆ
-- -- lemma6 (ğ•£ , stepâ‚‚ {Î»á¶œ = .(A â†’âˆ—âˆ¶ m)}  R~ ([3] {A}{m} _))               câˆˆ = lemma6 (ğ•£ , R~) câˆˆ
