<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SymbolicModel.Helpers</title><link rel="stylesheet" href="css/Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- Helpers for stripping.</a>
<a id="100" class="Comment">------------------------------------------------------------------------</a>

<a id="174" class="Keyword">open</a> <a id="179" class="Keyword">import</a> <a id="186" href="Data.List.html" class="Module">Data.List</a> <a id="196" class="Keyword">using</a> <a id="202" class="Symbol">(</a><a id="203" href="Data.List.Base.html#4297" class="Function">length</a><a id="209" class="Symbol">;</a> <a id="211" href="Data.List.Base.html#1497" class="Function">map</a><a id="214" class="Symbol">;</a> <a id="216" href="Data.List.Base.html#3883" class="Function">concatMap</a><a id="225" class="Symbol">;</a> <a id="227" href="Data.List.Base.html#1763" class="Function Operator">_++_</a><a id="231" class="Symbol">;</a> <a id="233" href="Data.List.Base.html#3243" class="Function">zip</a><a id="236" class="Symbol">)</a>
<a id="238" class="Keyword">open</a> <a id="243" class="Keyword">import</a> <a id="250" href="Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="285" class="Keyword">using</a> <a id="291" class="Symbol">(</a><a id="292" href="Data.List.Membership.Setoid.html#882" class="Function Operator">_∈_</a><a id="295" class="Symbol">;</a> <a id="297" href="Data.List.Membership.Setoid.html#931" class="Function Operator">_∉_</a><a id="300" class="Symbol">;</a> <a id="302" href="Data.List.Membership.Setoid.html#1123" class="Function">mapWith∈</a><a id="310" class="Symbol">)</a>

<a id="313" class="Keyword">open</a> <a id="318" class="Keyword">import</a> <a id="325" href="Prelude.Init.html" class="Module">Prelude.Init</a>
<a id="338" class="Keyword">open</a> <a id="343" class="Keyword">import</a> <a id="350" href="Prelude.Lists.html" class="Module">Prelude.Lists</a>
<a id="364" class="Keyword">open</a> <a id="369" class="Keyword">import</a> <a id="376" href="Prelude.DecEq.html" class="Module">Prelude.DecEq</a>
<a id="390" class="Keyword">open</a> <a id="395" class="Keyword">import</a> <a id="402" href="Prelude.Sets.html" class="Module">Prelude.Sets</a>

<a id="416" class="Keyword">open</a> <a id="421" class="Keyword">import</a> <a id="428" href="BitML.BasicTypes.html" class="Module">BitML.BasicTypes</a>

<a id="446" class="Keyword">module</a> <a id="453" href="SymbolicModel.Helpers.html" class="Module">SymbolicModel.Helpers</a>
  <a id="477" class="Symbol">(</a><a id="478" href="SymbolicModel.Helpers.html#478" class="Bound">Participant</a> <a id="490" class="Symbol">:</a> <a id="492" class="PrimitiveType">Set</a><a id="495" class="Symbol">)</a>
  <a id="499" class="Symbol">{{</a><a id="501" href="SymbolicModel.Helpers.html#501" class="Bound">_</a> <a id="503" class="Symbol">:</a> <a id="505" href="Prelude.DecEq.html#553" class="Record">DecEq</a> <a id="511" href="SymbolicModel.Helpers.html#478" class="Bound">Participant</a><a id="522" class="Symbol">}}</a>
  <a id="527" class="Symbol">(</a><a id="528" href="SymbolicModel.Helpers.html#528" class="Bound">Honest</a> <a id="535" class="Symbol">:</a> <a id="537" href="Data.List.NonEmpty.html#1318" class="Record">List⁺</a> <a id="543" href="SymbolicModel.Helpers.html#478" class="Bound">Participant</a><a id="554" class="Symbol">)</a>
  <a id="558" class="Keyword">where</a>

<a id="565" class="Keyword">open</a> <a id="570" class="Keyword">import</a> <a id="577" href="BitML.Contracts.Types.html" class="Module">BitML.Contracts.Types</a>                  <a id="616" href="SymbolicModel.Helpers.html#478" class="Bound">Participant</a> <a id="628" href="SymbolicModel.Helpers.html#528" class="Bound">Honest</a> <a id="635" class="Keyword">hiding</a> <a id="642" class="Symbol">(</a>c<a id="644" class="Symbol">)</a>
<a id="646" class="Keyword">open</a> <a id="651" class="Keyword">import</a> <a id="658" href="BitML.Semantics.Action.html" class="Module">BitML.Semantics.Action</a>                 <a id="697" href="SymbolicModel.Helpers.html#478" class="Bound">Participant</a> <a id="709" href="SymbolicModel.Helpers.html#528" class="Bound">Honest</a>
<a id="716" class="Keyword">open</a> <a id="721" class="Keyword">import</a> <a id="728" href="BitML.Semantics.Configurations.Types.html" class="Module">BitML.Semantics.Configurations.Types</a>   <a id="767" href="SymbolicModel.Helpers.html#478" class="Bound">Participant</a> <a id="779" href="SymbolicModel.Helpers.html#528" class="Bound">Honest</a>
<a id="786" class="Keyword">open</a> <a id="791" class="Keyword">import</a> <a id="798" href="BitML.Semantics.Configurations.Helpers.html" class="Module">BitML.Semantics.Configurations.Helpers</a> <a id="837" href="SymbolicModel.Helpers.html#478" class="Bound">Participant</a> <a id="849" href="SymbolicModel.Helpers.html#528" class="Bound">Honest</a>
<a id="856" class="Keyword">open</a> <a id="861" class="Keyword">import</a> <a id="868" href="BitML.Semantics.InferenceRules.html" class="Module">BitML.Semantics.InferenceRules</a>         <a id="907" href="SymbolicModel.Helpers.html#478" class="Bound">Participant</a> <a id="919" href="SymbolicModel.Helpers.html#528" class="Bound">Honest</a>
<a id="926" class="Keyword">open</a> <a id="931" class="Keyword">import</a> <a id="938" href="BitML.Semantics.Label.html" class="Module">BitML.Semantics.Label</a>                  <a id="977" href="SymbolicModel.Helpers.html#478" class="Bound">Participant</a> <a id="989" href="SymbolicModel.Helpers.html#528" class="Bound">Honest</a>

<a id="997" class="Keyword">open</a> <a id="1002" class="Keyword">import</a> <a id="1009" href="SymbolicModel.Strategy.html" class="Module">SymbolicModel.Strategy</a> <a id="1032" href="SymbolicModel.Helpers.html#478" class="Bound">Participant</a> <a id="1044" href="SymbolicModel.Helpers.html#528" class="Bound">Honest</a> <a id="1051" class="Symbol">as</a> <a id="SM"></a><a id="1054" href="SymbolicModel.Helpers.html#1054" class="Module">SM</a>

<a id="1058" class="Comment">{-
variable
  Δ : Configuration′ Iᶜᶠ[ [] &amp; rads , [] &amp; [] , [] &amp; [] ]
  Δs : List (Configuration Iᶜᶠ[ [] , [] , [] ])

  R R′ R″ : Run
  T T′ T″ : ∃TimedConfiguration

  c : Contracts ci

  ps : List Participant
  ss : List ValidSecret


strip-cases-helper : ((ci , c) ∷ cs′ ∣∣ᶜˢ Γ) ∗ᶜ
                   ≡ (  ⟨ c ⟩ᶜ
                     ∣∣ (cs′ ∣∣ᶜˢ Γ) ∗ᶜ
                     ∶- refl &amp; refl &amp; refl &amp; (\\-left {[ ci , c ]}) &amp; refl &amp; refl )
strip-cases-helper = refl

strip-cases : (cs′ ∣∣ᶜˢ Γ) ∗ᶜ ≡ (cs′ ∣∣ᶜˢ (Γ ∗ᶜ))
strip-cases {cs′ = []} = refl
strip-cases {cs′ = (ci , c) ∷ cs′} {ads} {cs} {ds} {Γ}
  rewrite strip-cases-helper {ci} {c} {cs′} {ads} {cs} {ds} {Γ}
        | strip-cases {cs′} {ads} {cs} {ds} {Γ}
        = refl

strip-ds : (ds′ ∣∣ᵈˢ Γ) ∗ᶜ ≡ (ds′ ∣∣ᵈˢ Γ ∗ᶜ)
strip-ds {ds′ = []} = refl
strip-ds {ds′ = d ∷ ds′} {Γ = Γ}
  rewrite strip-ds {ds′} {Γ = Γ} = refl

strip-ss : (ss ∣∣ˢˢ Γ) ∗ᶜ ≡ (ss ∣∣ˢˢ Γ ∗ᶜ)
strip-ss {ss = []} = refl
strip-ss {ss = s ∷ ss} {Γ = Γ}
  rewrite strip-ss {ss = ss} {Γ = Γ} = refl

strip-b : ∀ {i j} →
  (Γ ∣∣ᵇ (i , j , ps)) ∗ᶜ ≡ (Γ ∗ᶜ ∣∣ᵇ (i , j , ps))
strip-b {ps = []} = refl
strip-b {ps = p ∷ ps} = strip-b {ps = ps}

strip-committedParticipants : committedParticipants (Γp ∗ᶜ) ad
                            ≡ committedParticipants Γp ad
strip-committedParticipants {Γp = ∅ᶜ}              = refl
strip-committedParticipants {Γp = ` _}             = refl
strip-committedParticipants {Γp = ⟨ _ ⟩ᶜ}          = refl
strip-committedParticipants {Γp = ⟨ _ , _ ⟩ᵈ}      = refl
strip-committedParticipants {Γp = _ auth[ _ ]∶- _} = refl
strip-committedParticipants {Γp = ⟨ _ ∶ _ ♯ _ ⟩}   = refl
strip-committedParticipants {Γp = _ ∶ _ ♯ _}       = refl
strip-committedParticipants {Γp = l ∣∣ r ∶- _} {ad = ad}
  rewrite strip-committedParticipants {Γp = l} {ad = ad}
        | strip-committedParticipants {Γp = r} {ad = ad}
        = refl

strip-committedParticipants₂ :
    All (λ p → p ∈ committedParticipants Γp ad)                ps
  → All (λ p → p ∈ committedParticipants (Γp ∗ᶜ) ad) ps
strip-committedParticipants₂ {Γp = Γp} {ad = ad} p
  rewrite strip-committedParticipants {Γp = Γp} {ad = ad} = p

strip-spentForStipulation : spentForStipulation (Γp ∗ᶜ) ad
                          ≡ spentForStipulation Γp ad
strip-spentForStipulation {Γp = ∅ᶜ}              = refl
strip-spentForStipulation {Γp = ` _}             = refl
strip-spentForStipulation {Γp = ⟨ _ ⟩ᶜ}          = refl
strip-spentForStipulation {Γp = ⟨ _ , _ ⟩ᵈ}      = refl
strip-spentForStipulation {Γp = _ auth[ _ ]∶- _} = refl
strip-spentForStipulation {Γp = ⟨ _ ∶ _ ♯ _ ⟩}   = refl
strip-spentForStipulation {Γp = _ ∶ _ ♯ _}       = refl
strip-spentForStipulation {Γp = l ∣∣ r ∶- _} {ad = ad}
  rewrite strip-spentForStipulation {Γp = l} {ad = ad}
        | strip-spentForStipulation {Γp = r} {ad = ad}
        = refl

strip-spentForStipulation₂ : toStipulate (G ad) ≡ spentForStipulation Δ ad
                           → toStipulate (G ad) ≡ spentForStipulation (Δ ∗ᶜ) ad
strip-spentForStipulation₂ {ad = ad} {Δ = Δ} p
  rewrite strip-spentForStipulation {Γp = Δ} {ad = ad} = p


open import Data.List.Properties using (map-++-commute)
strip-cfgToList :
  cfgToList (Γp ∗ᶜ) ≡ map (map₂ _∗ᶜ) (cfgToList Γp)
strip-cfgToList {Γp = ∅ᶜ}              = refl
strip-cfgToList {Γp = ` _}             = refl
strip-cfgToList {Γp = ⟨ _ ⟩ᶜ}          = refl
strip-cfgToList {Γp = ⟨ _ , _ ⟩ᵈ}      = refl
strip-cfgToList {Γp = _ auth[ _ ]∶- _} = refl
strip-cfgToList {Γp = ⟨ _ ∶ _ ♯ _ ⟩}   = refl
strip-cfgToList {Γp = _ ∶ _ ♯ _}       = refl
strip-cfgToList {Γp = l ∣∣ r ∶- _}
  rewrite strip-cfgToList {Γp = l}
        | strip-cfgToList {Γp = r}
        = sym (map-++-commute (map₂ _∗ᶜ) (cfgToList l) (cfgToList r))

open import Data.List.Relation.Binary.Permutation.Inductive.Properties using (map⁺)
strip-≈ : Γp    ≈ Γp′
        → Γp ∗ᶜ ≈ Γp′ ∗ᶜ
strip-≈ {Γp = Γp} {Γp′ = Γp′} Γp≈
  rewrite strip-cfgToList {Γp = Γp}
        | strip-cfgToList {Γp = Γp′}
        = map⁺ (map₂ _∗ᶜ) Γp≈

strip-lastCfg : lastCfg (R ∗) ≡ (lastCfg R) ∗ᵗ
strip-lastCfg {_ ∙ˢ}        = refl
strip-lastCfg {_ ∷ˢ⟦ _ ⟧ _} = refl

strip-idempotent : ∀ (γ : Configuration′ cf′i) →
  (γ ∗ᶜ) ∗ᶜ ≡ γ ∗ᶜ
strip-idempotent ∅ᶜ                = refl
strip-idempotent (` _)             = refl
strip-idempotent ⟨ _ ⟩ᶜ            = refl
strip-idempotent ⟨ _ , _ ⟩ᵈ        = refl
strip-idempotent (_ auth[ _ ]∶- _) = refl
strip-idempotent ⟨ _ ∶ _ ♯ _ ⟩     = refl
strip-idempotent (_ ∶ _ ♯ _)       = refl
strip-idempotent (l ∣∣ r ∶- _)     rewrite strip-idempotent l
                                        | strip-idempotent r
                                        = refl

strip-strip-rewrite : ∀ {l : Configuration Iᶜᶠ[ ads , cs , ds ]} {γ : Configuration Iᶜᶠ[ ads′ , cs′ , ds′ ]} {pr}
  → (_∣∣_∶-_ {ads = ads ++ ads′} {rads = []}
             {cs = cs  ++ cs′} {rcs = []}
             {ds = ds ++ ds′} {rds = []}
             l ((γ ∗ᶜ) ∗ᶜ) pr)
  ≡ (l ∣∣ γ ∗ᶜ ∶- pr)
strip-strip-rewrite {γ = γ}
  rewrite strip-idempotent γ
        = refl

help : R ∗ ——→[ α ] T′
     → proj₂ ((lastCfg R) ∗ᵗ) —→ₜ[ α ] proj₂ T′
help {R = _ ∙ˢ}        R→ = R→
help {R = _ ∷ˢ⟦ _ ⟧ _} R→ = R→

destruct-γ∗ : ∀ {Γ Γ₀ : Configuration′ Iᶜᶠ[ ads &amp; rads , cs &amp; rcs , ds &amp; rds ]}
                {l    : Configuration Iᶜᶠ[ ads′ , cs′ , ds′ ]}
                {γ∗   : Configuration′ Iᶜᶠ[ adsʳ &amp; radsʳ , csʳ &amp; rcsʳ , dsʳ &amp; rdsʳ ]}
                {pr   : ads  ≡ ads′ ++ adsʳ
                      × rads ≡ [] ++ (radsʳ \\ ads′)
                      × cs   ≡ cs′  ++ csʳ
                      × rcs  ≡ [] ++ (rcsʳ \\ cs′)
                      × ds   ≡ (ds′ \\ rdsʳ) ++ dsʳ
                      × rds  ≡ [] ++ (rdsʳ \\ ds′) }
  → Γ₀ ≡ Γ ∗ᶜ
  → Γ₀ ≡ (l ∗ᶜ ∣∣ γ∗ ∶- pr)
  → ∃[ γ ] ( (γ∗ ≡ γ ∗ᶜ)
           × (Γ ≡ (l ∣∣ γ ∶- pr)) )
destruct-γ∗ {Γ = ∅ᶜ}              refl ()
destruct-γ∗ {Γ = ` _}             refl ()
destruct-γ∗ {Γ = ⟨ _ ⟩ᶜ}          refl ()
destruct-γ∗ {Γ = ⟨ _ , _ ⟩ᵈ}      refl ()
destruct-γ∗ {Γ = _ auth[ _ ]∶- _} refl ()
destruct-γ∗ {Γ = ⟨ _ ∶ _ ♯ _ ⟩}   refl ()
destruct-γ∗ {Γ = _ ∶ _ ♯ _}       refl ()
destruct-γ∗ {Γ = l′ ∣∣ γ ∶- pr₂} {Γ₀ = Γ₀} {l = l} {γ∗ = γ∗} {pr = pr₁} p0 p
  with pr₁
... | (refl , refl , refl , refl , refl , refl)
    = {! γ , refl , refl !}

data Singleton {a} {A : Set a} (x : A) : Set a where
  _with≡_ : (y : A) → x ≡ y → Singleton x

inspect : ∀ {a} {A : Set a} (x : A) → Singleton x
inspect x = x with≡ refl

-}</a>
</pre></body></html>