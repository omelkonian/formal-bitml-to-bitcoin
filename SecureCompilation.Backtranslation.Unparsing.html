<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SecureCompilation.Backtranslation.Unparsing</title><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css'/><style>.github-fork-ribbon:before { background-color: #333; }</style><link rel="stylesheet" href="css/Agda.css"></head><body><a class='github-fork-ribbon'href='https://github.com/omelkonian/formal-bitml-to-bitcoin/tree/master/SecureCompilation/Backtranslation/Unparsing.agda'data-ribbon='Source code on Github' title='Source code on Github'>Source code on Github</a><pre class="Agda"><a id="1" class="Comment">---------------------------------------------------</a>
<a id="53" class="Comment">-- Converting symbolic moves to computational ones.</a>
<a id="105" class="Comment">---------------------------------------------------</a>

<a id="158" class="Comment">-- {-# OPTIONS --allow-unsolved-metas #-}</a>
<a id="200" class="Keyword">open</a> <a id="205" class="Keyword">import</a> <a id="212" href="Prelude.Init.html" class="Module">Prelude.Init</a> <a id="225" class="Keyword">hiding</a> <a id="232" class="Symbol">(</a><a id="233" href="Data.Bool.Base.html#1460" class="Function">T</a><a id="234" class="Symbol">)</a>
<a id="236" class="Keyword">open</a> <a id="241" href="Prelude.Init.html#7254" class="Module">L.Mem</a> <a id="247" class="Keyword">using</a> <a id="253" class="Symbol">(</a><a id="254" href="Data.List.Membership.Setoid.html#896" class="Function Operator">_∈_</a><a id="257" class="Symbol">;</a> <a id="259" href="Data.List.Membership.Propositional.Properties.html#3491" class="Function">∈-map⁻</a><a id="265" class="Symbol">)</a>
<a id="267" class="Keyword">open</a> <a id="272" class="Keyword">import</a> <a id="279" href="Prelude.Lists.html" class="Module">Prelude.Lists</a>
<a id="293" class="Keyword">open</a> <a id="298" class="Keyword">import</a> <a id="305" href="Prelude.Lists.Dec.html" class="Module">Prelude.Lists.Dec</a>
<a id="323" class="Keyword">open</a> <a id="328" class="Keyword">import</a> <a id="335" href="Prelude.DecEq.html" class="Module">Prelude.DecEq</a>
<a id="349" class="Keyword">open</a> <a id="354" class="Keyword">import</a> <a id="361" href="Prelude.Traces.html" class="Module">Prelude.Traces</a>
<a id="376" class="Keyword">open</a> <a id="381" class="Keyword">import</a> <a id="388" href="Prelude.Membership.html" class="Module">Prelude.Membership</a> <a id="407" class="Keyword">hiding</a> <a id="414" class="Symbol">(</a><a id="415" href="Prelude.Membership.html#428" class="Field Operator">_∈_</a><a id="418" class="Symbol">)</a>
<a id="420" class="Keyword">open</a> <a id="425" class="Keyword">import</a> <a id="432" href="Prelude.Ord.html" class="Module">Prelude.Ord</a>
<a id="444" class="Keyword">open</a> <a id="449" class="Keyword">import</a> <a id="456" href="Prelude.Decidable.html" class="Module">Prelude.Decidable</a>
<a id="474" class="Keyword">open</a> <a id="479" class="Keyword">import</a> <a id="486" href="Prelude.Validity.html" class="Module">Prelude.Validity</a>
<a id="503" class="Keyword">open</a> <a id="508" class="Keyword">import</a> <a id="515" href="Prelude.Setoid.html" class="Module">Prelude.Setoid</a>
<a id="530" class="Keyword">open</a> <a id="535" class="Keyword">import</a> <a id="542" href="Prelude.InferenceRules.html" class="Module">Prelude.InferenceRules</a>
<a id="565" class="Keyword">open</a> <a id="570" class="Keyword">import</a> <a id="577" href="Prelude.Lists.Collections.html" class="Module">Prelude.Lists.Collections</a>
<a id="603" class="Keyword">open</a> <a id="608" class="Keyword">import</a> <a id="615" href="Prelude.Semigroup.html" class="Module">Prelude.Semigroup</a>
<a id="633" class="Keyword">open</a> <a id="638" class="Keyword">import</a> <a id="645" href="Prelude.ToList.html" class="Module">Prelude.ToList</a>
<a id="660" class="Keyword">open</a> <a id="665" class="Keyword">import</a> <a id="672" href="Prelude.Functor.html" class="Module">Prelude.Functor</a>
<a id="688" class="Keyword">open</a> <a id="693" class="Keyword">import</a> <a id="700" href="Prelude.Nary.html" class="Module">Prelude.Nary</a> <a id="713" class="Keyword">hiding</a> <a id="720" class="Symbol">(</a><a id="721" href="Prelude.Nary.html#246" class="Function Operator">⟦_⟧</a><a id="724" class="Symbol">)</a>
<a id="726" class="Keyword">open</a> <a id="731" class="Keyword">import</a> <a id="738" href="Prelude.General.html" class="Module">Prelude.General</a>

<a id="755" class="Keyword">open</a> <a id="760" class="Keyword">import</a> <a id="767" href="SecureCompilation.ModuleParameters.html" class="Module">SecureCompilation.ModuleParameters</a> <a id="802" class="Keyword">using</a> <a id="808" class="Symbol">(</a><a id="809" href="SecureCompilation.ModuleParameters.html#209" class="Record">⋯</a><a id="810" class="Symbol">)</a>

<a id="813" class="Keyword">module</a> <a id="820" href="SecureCompilation.Backtranslation.Unparsing.html" class="Module">SecureCompilation.Backtranslation.Unparsing</a>
  <a id="866" class="Symbol">(</a><a id="867" href="SecureCompilation.Backtranslation.Unparsing.html#867" class="Bound">⋯</a> <a id="869" class="Symbol">:</a> <a id="871" href="SecureCompilation.ModuleParameters.html#209" class="Record">⋯</a><a id="872" class="Symbol">)</a> <a id="874" class="Symbol">(</a><a id="875" class="Keyword">let</a> <a id="879" class="Keyword">open</a> <a id="884" href="SecureCompilation.ModuleParameters.html#209" class="Module">⋯</a> <a id="886" href="SecureCompilation.Backtranslation.Unparsing.html#867" class="Bound">⋯</a><a id="887" class="Symbol">)</a>
  <a id="891" class="Symbol">(</a><a id="892" href="SecureCompilation.Backtranslation.Unparsing.html#892" class="Bound">A₀</a> <a id="895" class="Symbol">:</a> <a id="897" href="BitML.BasicTypes.html#675" class="Function">Participant</a><a id="908" class="Symbol">)</a> <a id="910" class="Comment">-- whose strategy we are currently translating</a>
  <a id="959" class="Keyword">where</a>

<a id="966" class="Keyword">open</a> <a id="971" class="Keyword">import</a> <a id="978" href="Compiler.html" class="Module">Compiler</a> <a id="987" href="SecureCompilation.ModuleParameters.html#282" class="Field">⋯′</a> <a id="990" href="SecureCompilation.ModuleParameters.html#357" class="Field">η</a>
<a id="992" class="Keyword">open</a> <a id="997" class="Keyword">import</a> <a id="1004" href="SymbolicModel.html" class="Module">SymbolicModel</a> <a id="1018" href="SecureCompilation.ModuleParameters.html#282" class="Field">⋯′</a> as <a id="S"></a><a id="1024" href="SecureCompilation.Backtranslation.Unparsing.html#1024" class="Module">S</a>
  <a id="1028" class="Keyword">hiding</a> <a id="1035" class="Symbol">(</a><a id="1036" href="SymbolicModel.Run.Base.html#468" class="Generalizable">Rˢ′</a><a id="1039" class="Symbol">;</a> <a id="1041" href="BitML.Contracts.Types.html#1222" class="Generalizable">d</a><a id="1042" class="Symbol">)</a>
<a id="1044" class="Keyword">open</a> <a id="1049" class="Keyword">import</a> <a id="1056" href="ComputationalModel.html" class="Module">ComputationalModel</a> <a id="1075" href="SecureCompilation.ModuleParameters.html#282" class="Field">⋯′</a> <a id="1078" href="SecureCompilation.ModuleParameters.html#450" class="Field">finPart</a> <a id="1086" href="SecureCompilation.ModuleParameters.html#487" class="Field">keypairs</a> as <a id="C"></a><a id="1098" href="SecureCompilation.Backtranslation.Unparsing.html#1098" class="Module">C</a>
  <a id="1102" class="Keyword">hiding</a> <a id="1109" class="Symbol">(</a><a id="1110" href="ComputationalModel.Strategy.html#1317" class="Field">Σ</a><a id="1111" class="Symbol">;</a> <a id="1113" href="Bitcoin.BasicTypes.html#429" class="Generalizable">t</a><a id="1114" class="Symbol">;</a> <a id="1116" href="Bitcoin.BasicTypes.html#431" class="Generalizable">t′</a><a id="1118" class="Symbol">;</a> <a id="1120" href="Bitcoin.Script.Base.html#821" class="InductiveConstructor">`</a><a id="1121" class="Symbol">;</a> <a id="1123" href="Bitcoin.Script.Base.html#1071" class="InductiveConstructor Operator">∣_∣</a><a id="1126" class="Symbol">;</a> <a id="1128" href="Bitcoin.BasicTypes.html#418" class="Generalizable">n</a><a id="1129" class="Symbol">)</a>
<a id="1131" class="Keyword">open</a> <a id="1136" class="Keyword">import</a> <a id="1143" href="Coherence.html" class="Module">Coherence</a> <a id="1153" href="SecureCompilation.Backtranslation.Unparsing.html#867" class="Bound">⋯</a>

<a id="1156" class="Keyword">postulate</a>
  <a id="unparseMove"></a><a id="1168" href="SecureCompilation.Backtranslation.Unparsing.html#1168" class="Postulate">unparseMove</a> <a id="1180" class="Symbol">:</a>
    <a id="1186" href="Prelude.InferenceRules.html#56141" class="Function Operator">∙</a> <a id="1188" href="SymbolicModel.Run.Base.html#465" class="Generalizable">Rˢ</a> <a id="1191" href="Coherence.Relation.html#5522" class="Function Operator">~</a> <a id="1193" href="ComputationalModel.Run.html#4351" class="Generalizable">Rᶜ</a>
    <a id="1200" href="Prelude.InferenceRules.html#56072" class="Function Operator">∙</a> <a id="1202" href="SymbolicModel.Run.Base.html#465" class="Generalizable">Rˢ</a> <a id="1205" href="SymbolicModel.Run.Base.html#1301" class="Function Operator">——[</a> <a id="1209" href="BitML.Semantics.Label.html#1651" class="Generalizable">α</a> <a id="1211" href="SymbolicModel.Run.Base.html#1301" class="Function Operator">]→</a> <a id="1214" href="BitML.Semantics.Configurations.Types.html#1456" class="Generalizable">Γₜ</a>
      <a id="1223" href="Prelude.InferenceRules.html#13868" class="Function Operator">─────────────────────────────</a>
      <a id="1259" href="Data.Product.html#1378" class="Function">∃</a> <a id="1261" class="Symbol">λ</a> <a id="1263" href="SecureCompilation.Backtranslation.Unparsing.html#1263" class="Bound">λᶜ</a> <a id="1266" class="Symbol">→</a> <a id="1268" href="Data.Product.html#1378" class="Function">∃</a> <a id="1270" class="Symbol">λ</a> <a id="1272" class="Symbol">(</a><a id="1273" href="SecureCompilation.Backtranslation.Unparsing.html#1273" class="Bound">𝕒</a> <a id="1275" class="Symbol">:</a> <a id="1277" href="SymbolicModel.Run.Base.html#2285" class="Function">𝔸</a> <a id="1279" href="SymbolicModel.Run.Base.html#465" class="Generalizable">Rˢ</a> <a id="1282" href="BitML.Semantics.Configurations.Types.html#1456" class="Generalizable">Γₜ</a><a id="1284" class="Symbol">)</a> <a id="1286" class="Symbol">→</a>
        <a id="1296" class="Symbol">(</a><a id="1297" href="BitML.Semantics.Configurations.Types.html#1456" class="Generalizable">Γₜ</a> <a id="1300" href="SymbolicModel.Run.Base.html#2412" class="Function Operator">∷</a> <a id="1302" href="SymbolicModel.Run.Base.html#465" class="Generalizable">Rˢ</a> <a id="1305" href="SymbolicModel.Run.Base.html#2412" class="Function Operator">⊣</a> <a id="1307" href="SecureCompilation.Backtranslation.Unparsing.html#1273" class="Bound">𝕒</a><a id="1308" class="Symbol">)</a> <a id="1310" href="Coherence.Relation.html#5522" class="Function Operator">~</a> <a id="1312" class="Symbol">(</a><a id="1313" href="SecureCompilation.Backtranslation.Unparsing.html#1263" class="Bound">λᶜ</a> <a id="1316" href="ComputationalModel.Run.html#4314" class="InductiveConstructor Operator">∷</a> <a id="1318" href="ComputationalModel.Run.html#4351" class="Generalizable">Rᶜ</a> <a id="1321" href="ComputationalModel.Run.html#4314" class="InductiveConstructor Operator">✓</a><a id="1322" class="Symbol">)</a>
<a id="1324" class="Comment">-- ** too slow</a>
<a id="1339" class="Comment">{-
unparseMove
  {Rˢ@(record {end = Γₜ@(Γ at t)})}
  {Rᶜ}
  {advertise⦅ ⟨G⟩C ⦆}
  {Γₜ′@(Γ′@(` .⟨G⟩C ∣ .Γ) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  ([Action] ([C-Advertise] vad hon d⊆) refl) =
    -, -, -, step₁ Rˢ~Rᶜ
      ([L1] mkℍ {mk {⟨G⟩C}{Γ}{t} vad hon d⊆
                    (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)}
                {A = ?})
unparseMove
  {Rˢ@(record {end = Γₜ@(
    Γ@(` .⟨G⟩C ∣ Γ₀)
    at t)})}
  {Rᶜ}
  {auth-commit⦅ A , ⟨G⟩C , Δ ⦆}
  {Γₜ′@(Γ′@(.Γ ∣ Δᶜ ∣ .A auth[ ♯▷ .⟨G⟩C ]) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  ([Action] ([C-AuthCommit] as≡ All∉ Hon⇒) refl) =
  let
    R≈ : Rˢ ≈⋯ Γₜ
    R≈ = refl , ↭-refl

    ∃Γ≈ : ∃ (_≈ Γ′)
    ∃Γ≈ = Γ′ , ↭-refl
  in
    -, -, -, step₁ Rˢ~Rᶜ
      ([L2] mkℍ {mk {⟨G⟩C}{Γ₀}{t}{A} ? ? as≡ All∉ Hon⇒
                    (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)}
                ? ? ? ? ? ? ?)
unparseMove
  {Rˢ@(record {end = Γₜ@(
    Γ@(` .ad ∣ Γ₀)
    at t)})}
  {Rᶜ}
  {auth-init⦅ A , ad , x ⦆}
  {Γₜ′@(Γ′@(` .ad ∣ .Γ₀ ∣ .A auth[ .x ▷ˢ .ad ]) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  ([Action] ([C-AuthInit] committedA A∈per) refl) =
    -, -, -, step₁ Rˢ~Rᶜ
      ([L3] mkℍ {mk {ad}{Γ₀}{t}{A}{x} committedA A∈per
                    (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)}
                ? ?)
unparseMove
  {Rˢ@(record {end = Γₜ@(
    Γ@( .(` (⟨ G ⟩ C)) ∣ Γ₀ ∣ _ ∣ _)
    at t)})}
  {Rᶜ}
  {init⦅ G , C ⦆}
  {Γₜ′@(Γ′@(_) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  ([Action] ([C-Init] fresh-z) refl) =
    -, -, -, step₁ Rˢ~Rᶜ
      ([L4] mkℍ {mk {⟨ G ⟩ C}{Γ₀}{t} fresh-z
                    (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)})
unparseMove
  {Rˢ@(record {end = Γₜ@(
    Γ@(⟨ c , v ⟩at .x ∣ Γ₀)
    at t)})}
  {Rᶜ}
  {auth-control⦅ A , x ▷ d ⦆}
  {Γₜ′@(Γ′@(⟨ .c , .v ⟩at .x ∣ A auth[ .x ▷ d ] ∣ .Γ₀) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  ([Action] ([C-AuthControl] d≡) refl) =
    -, -, -, step₁ Rˢ~Rᶜ
      ([L5] mkℍ {mk {c}{v}{x}{Γ₀}{t}{A}{i = ?} d≡
                    (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)}
                ? ?)
unparseMove
  {Rˢ@(record {end = Γₜ@(
    Γ@(_)
    at t)})}
  {Rᶜ}
  {put⦅ xs , as , y ⦆}
  {Γₜ′@(Γ′@(_) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  stepₜ@([Timeout] As≡∅ ∀≤t _ refl)
  with ds , ss , p , c , v , Γ₀ , z , d≡ , refl , refl , refl , refl , refl , refl
     , fresh-z , p≡
     ← match-putₜ stepₜ tt =
    -, -, -, step₁ Rˢ~Rᶜ
      ([L6] mkℍ {mk {_}{v}{y}{c}{z}{Γ₀ = Γ₀}{_}{p}{ds}{ss}{i = ?}
                    (∀≤⇒≡max ∀≤t) d≡ fresh-z p≡ As≡∅
                    (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)})
unparseMove
  {Rˢ@(record {end = Γₜ@(
    Γ@(⟨ .A ∶ .a ♯ just n ⟩ ∣ Γ₀)
    at t)})}
  {Rᶜ}
  {auth-rev⦅ A , a ⦆}
  {Γₜ′@(Γ′@(.A ∶ .a ♯ .n ∣ .Γ₀) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  ([Action] [C-AuthRev] refl) =
  -, -, -, step₁ Rˢ~Rᶜ
      ([L7] mkℍ {mk {ad = ?}{A}{a}{n}{Γ₀}{t} ? ?
                    (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)
                    ?}
                ? ? ? ? ?)
  -- ([L] [7] {Γ₀ = Γ₀} {B = A₀} m≤ R≈ ∃Γ≈ ∃B ∃α a∈G ∃λ first-λᶜ)
  where
    postulate
      _m : Message
      m≤ : ∣ _m ∣ᵐ ≤ η
      Δ×h̅ : List (Secret × Maybe ℕ × ℤ)
      ⟨G⟩C : Ad
      k⃗ : 𝕂²′ ⟨G⟩C

    R≈ : Rˢ ≈⋯ Γₜ
    R≈ = refl , ↭-refl

    ∃Γ≈ : ∃ (_≈ Γ′)
    ∃Γ≈ = Γ′ , ↭-refl

    𝕣 = ℝ∗⇒ℝ 𝕣∗; open ℝ 𝕣

    a∈ : a ∈ namesˡ Rˢ
    a∈ = namesˡ⦅end⦆⊆ Rˢ
       $ ∈namesˡ-resp-≈ a {Γ}{cfg (Rˢ .end)} (↭-sym $ proj₂ R≈) (here refl)

    _Δ : List (Secret × Maybe ℕ)
    _Δ = map (λ{ (s , mn , _) → s , mn }) Δ×h̅

    _C : Message
    _C = encodeAd ⟨G⟩C {!!} -- (txoutG , txoutC)

    -- h̅ : Message
    -- h̅ = map (proj₂ ∘ proj₂) Δ×h̅

    -- k̅ : Message
    -- k̅ = concatMap (map pub ∘ codom) (codom k⃗)

    -- C,h̅,k̅ : Message
    -- C,h̅,k̅ = _C ◇ h̅ ◇ k̅

    -- postulate
    --   ∃B : ∃ λ B → (B , _m , [ sechash′ {a} a∈ ]) ∈ oracleInteractionsᶜ Rᶜ
    --   ∃α : auth-commit⦅ A , ⟨G⟩C , _Δ ⦆ ∈ labels Rˢ
    --   a∈G : a ∈ namesˡ (⟨G⟩C .G)

    --   ∃λ : Any (λ l → ∃ λ B → l ≡ B →∗∶ C,h̅,k̅) (toList Rᶜ)
    --   first-λᶜ : All (λ l → ∀ X → l ≢ X →∗∶ _m) (Any-tail ∃λ)
unparseMove
  {Rˢ@(record {end = Γₜ@(
    Γ@(⟨ c , v ⟩at .y ∣ Γ₀)
    at t)})}
  {Rᶜ}
  {split⦅ y ⦆}
  {Γₜ′@(Γ′@(_) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  stepₜ@([Timeout] As≡∅ ∀≤t _ refl)
  with vcis , Γ₀ , y , d≡ , refl , refl , refl , refl , fresh-xs ← match-splitₜ stepₜ tt =
    -, -, -, step₁ Rˢ~Rᶜ
      ([L8] mkℍ {mk {c}{y}{Γ₀}{i = ?}{vcis} (∀≤⇒≡max ∀≤t) d≡ fresh-xs As≡∅
                    (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)})
unparseMove
  {Rˢ@(record {end = Γₜ@(
    Γ@(_)
    at t)})}
  {Rᶜ}
  {withdraw⦅ A , v , y ⦆}
  {Γₜ′@(Γ′@(_) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  stepₜ@([Timeout] As≡∅ ∀≤t _ refl)
  with Γ₀ , x , d≡ , refl , refl , refl , refl , fresh-x ← match-withdrawₜ stepₜ tt =
    -, -, -, step₁ Rˢ~Rᶜ
      ([L9] mkℍ {mk {Γ₀ = Γ₀} d≡ fresh-x As≡∅ ∀≤t
                    (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)})
unparseMove
  {Rˢ@(record {end = Γₜ@(Γ@(⟨ A has v ⟩at .x ∣ ⟨ A has v′ ⟩at .x′ ∣ Γ₀) at t)})}
  {Rᶜ}
  {auth-join⦅ A , x ↔ x′ ⦆}
  {Γₜ′@(Γ′@(⟨ .A has .v ⟩at .x ∣ ⟨ .A has .v′ ⟩at .x′ ∣ .A auth[ .x ↔ .x′ ▷⟨ .A , .(v + v′) ⟩ ] ∣ Γ₀) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  ([Action] [DEP-AuthJoin] refl) =
  let
    𝕣 = ℝ∗⇒ℝ 𝕣∗; open ℝ 𝕣

    R≈ : Rˢ ≈⋯ Γₜ
    R≈ = refl , ↭-refl

    ∃Γ≈ : ∃ (_≈ Γ′)
    ∃Γ≈ = Γ′ , ↭-refl

    n⊆ : Γ ⊆⦅ namesʳ ⦆ Rˢ
    n⊆  = namesʳ⦅end⦆⊆ Rˢ ∘ ∈namesʳ-resp-≈ _ {Γ}{cfg (Rˢ .end)} (↭-sym $ proj₂ R≈)
    x∈  = n⊆ (here refl)
    x∈′ = n⊆ (there $′ here refl)

    -- ∃λ : Any (λ l → ∃ λ B → ∃ λ T
    --      → (l ≡ B →∗∶ [ T ♯ ])
    --      × (inputs  T ≡ hashTxⁱ (txout′ {x} x∈) ∷ hashTxⁱ (txout′ {x′} x∈′) ∷ [])
    --      × (outputs T ≡ [ 1 , record {value = v + v′; validator = ƛ (versig [ K̂ A ] [ # 0 ])} ])
    --      ) (toList Rᶜ)
    -- ∃λ = {!!}

    -- T : ∃Tx
    -- T = 2 , 1 , (L.Any.satisfied ∃λ .proj₂ .proj₂ .proj₁)

    -- m′ = [ SIG (K̂ A) T ]

    -- first-λᶜ : All (λ l → ¬ ∃ λ B → l ≡ B →∗∶ m′) (Any-tail ∃λ)
    -- first-λᶜ = {!!}
  in
    -, -, -, step₁ Rˢ~Rᶜ
      ([L10] mkℍ {mk {Γ₀ = Γ₀}
                     (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)}
                 ? ?)
unparseMove
  {Rˢ@(record {end = Γₜ@(
    Γ@(⟨ A has v ⟩at x ∣ ⟨ A has v′ ⟩at x′ ∣ .A auth[ .x ↔ .x′ ▷⟨ .A , .(v + v′) ⟩ ] ∣ Γ₀)
    at t)})}
  {Rᶜ}
  {α@(join⦅ x ↔ x′ ⦆)}
  {Γₜ′@(Γ′@(⟨ .A has .(v + v′) ⟩at y ∣ .Γ₀) at t′@(.t))}
  (𝕣∗ , Rˢ~Rᶜ)
  Γ→Γ′@([Action] ([DEP-Join] fresh-y) refl) =
  let
    R≈ : Rˢ ≈⋯ Γₜ
    R≈ = refl , ↭-refl

    ∃Γ≈ : ∃ (_≈ Γ′)
    ∃Γ≈ = Γ′ , ↭-refl
  in
    -, -, -, step₁ Rˢ~Rᶜ
      ([L11] mkℍ {mk {Γ₀ = Γ₀} fresh-y
                     (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)})
unparseMove
  {Rˢ@(record {end = Γₜ@(Γ@(⟨ .A has .(v + v′) ⟩at .x ∣ Γ₀) at t)})}
  {Rᶜ}
  {auth-divide⦅ A , x ▷ v , v′ ⦆}
  {Γₜ′@(Γ′@(⟨ .A has .(v + v′) ⟩at .x ∣ .A auth[ .x ▷⟨ .A , .v , .v′ ⟩ ] ∣ .Γ₀) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  Γ→Γ′@([Action] [DEP-AuthDivide] refl) =
  let
    𝕣 = ℝ∗⇒ℝ 𝕣∗; open ℝ 𝕣

    R≈ : Rˢ ≈⋯ Γₜ
    R≈ = refl , ↭-refl

    ∃Γ≈ : ∃ (_≈ Γ′)
    ∃Γ≈ = Γ′ , ↭-refl

    n⊆ : Γ ⊆⦅ namesʳ ⦆ Rˢ
    n⊆  = namesʳ⦅end⦆⊆ Rˢ ∘ ∈namesʳ-resp-≈ _ {Γ}{cfg (Rˢ .end)} (↭-sym $ proj₂ R≈)
    x∈  = n⊆ (here refl)

    -- ∃λ : Any (λ l → ∃ λ B → ∃ λ T
    --      → (l ≡ B →∗∶ [ T ♯ ])
    --      × (inputs  T ≡ [ hashTxⁱ (txout′ {x} x∈) ])
    --      × (outputs T ≡ (v redeemable-by K̂ A) ∷ (v′ redeemable-by K̂ A) ∷ [])
    --      ) (toList Rᶜ)
    -- ∃λ = {!!}

    -- T : ∃Tx
    -- T = 1 , 2 , (L.Any.satisfied ∃λ .proj₂ .proj₂ .proj₁)

    -- m′ = [ SIG (K̂ A) T ]

    -- first-λᶜ : All (λ l → ¬ ∃ λ B → l ≡ B →∗∶ m′) (Any-tail ∃λ)
    -- first-λᶜ = {!!}
  in
    -, -, -, step₁ Rˢ~Rᶜ
      ([L12] mkℍ {mk {Γ₀ = Γ₀}
                    (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)}
                ? ?)
 -- ([L] [12] {Γ₀ = Γ₀} {B = {!!}} R≈ ∃Γ≈ ∃λ first-λᶜ)
unparseMove
  {Rˢ@(record {end = Γₜ@(
    Γ@(⟨ A has .(v + v′) ⟩at .x ∣ .A auth[ .x ▷⟨ .A , .v , .v′ ⟩ ] ∣ Γ₀)
    at t)})}
  {Rᶜ}
  {divide⦅ x ▷ v , v′ ⦆}
  {Γₜ′@(Γ′@(⟨ .A has .v ⟩at y ∣ ⟨ .A has .v′ ⟩at y′ ∣ .Γ₀) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  ([Action] ([DEP-Divide] fresh-ys) refl) =
    -, -, -, step₁ Rˢ~Rᶜ
      ([L13] mkℍ {mk {Γ₀ = Γ₀} fresh-ys (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)})
unparseMove
  {Rˢ@(record {end = Γₜ@(
    Γ@(⟨ .A has v ⟩at .x ∣ Γ₀)
    at t)})}
  {Rᶜ}
  {auth-donate⦅ A , x ▷ᵈ B′ ⦆}
  {Γₜ′@(Γ′@(⟨ .A has .v ⟩at .x ∣ .A auth[ .x ▷ᵈ .B′ ] ∣ .Γ₀) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  ([Action] [DEP-AuthDonate] refl) =
  let
    𝕣 = ℝ∗⇒ℝ 𝕣∗; open ℝ 𝕣

    R≈ : Rˢ ≈⋯ Γₜ
    R≈ = refl , ↭-refl

    ∃Γ≈ : ∃ (_≈ Γ′)
    ∃Γ≈ = Γ′ , ↭-refl

    n⊆ : Γ ⊆⦅ namesʳ ⦆ Rˢ
    n⊆  = namesʳ⦅end⦆⊆ Rˢ ∘ ∈namesʳ-resp-≈ _ {Γ}{cfg (Rˢ .end)} (↭-sym $ proj₂ R≈)
    x∈  = n⊆ (here refl)

    -- ∃λ : Any (λ l → ∃ λ B → ∃ λ T
    --          → (l ≡ B →∗∶ [ T ♯ ])
    --          × (inputs  T ≡ [ hashTxⁱ (txout′ {x} x∈) ])
    --          × (outputs T ≡ [ v redeemable-by K̂ B′ ])
    --          ) (toList Rᶜ)
    -- ∃λ = {!!}

    -- T : ∃Tx
    -- T = 1 , 1 , (proj₁ $ proj₂ $ proj₂ $ L.Any.satisfied ∃λ)

    -- m′ = [ SIG (K̂ A) T ]

    -- first-λᶜ : All (λ l → ¬ ∃ λ B → l ≡ B →∗∶ m′) (Any-tail ∃λ)
    -- first-λᶜ = {!!}
  in
    -, -, -, step₁ Rˢ~Rᶜ
      ([L14] mkℍ {mk {Γ₀ = Γ₀} (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)}
                 ? ?)
    -- ([L] [14] {Γ₀ = Γ₀} {B = {!!}} R≈ ∃Γ≈ ∃λ first-λᶜ)
unparseMove
  {Rˢ@(record {end = Γₜ@(
    Γ@(⟨ A has v ⟩at .x ∣ A auth[ .x ▷ᵈ .B′ ] ∣ Γ₀)
    at t)})}
  {Rᶜ}
  {donate⦅ x ▷ᵈ B′ ⦆}
  {Γₜ′@(Γ′@(⟨ .B′ has .v ⟩at y ∣ .Γ₀) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  ([Action] ([DEP-Donate] fresh-y) refl) =
  let
    R≈ : Rˢ ≈⋯ Γₜ
    R≈ = refl , ↭-refl

    ∃Γ≈ : ∃ (_≈ Γ′)
    ∃Γ≈ = Γ′ , ↭-refl
  in
    -, -, -, step₁ Rˢ~Rᶜ
      ([L15] mkℍ {mk {Γ₀ = Γ₀} fresh-y
                 (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)})
-- ** unification errors for `destroy` actions, T0D0: fording view
{-
unparseMove
  {Rˢ@(record {end = Γₜ@(
    Γ@(Δ ∣ Γ₀)
    at t)})}
  {Rᶜ}
  {auth-destroy⦅ A , xs , j′ ⦆}
  {Γₜ′@(Γ′@(.Δ ∣ .A auth[ .xs , .j′ ▷ᵈˢ y ] ∣ .Γ₀) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  ([Action] ([DEP-AuthDestroy] {y}{Γ₀}{ds}{j} fresh-y) refl) =
    -, -, -, step₁ Rˢ~Rᶜ
      ([R16⊣ ? ] mkℍ {mk {y}{Γ₀}{t}{ds} j fresh-y
                         (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)}
                     ? ?)
      -- {Γ₀ = Γ₀} {i = {!!}} {B = A₀} {ds = ds}
unparseMove
  {Rˢ@(record {end = Γₜ@(
    Γ@(_ ∣ Γ₀)
    at t)})}
  {Rᶜ}
  {destroy⦅ xs ⦆}
  {Γₜ′@(Γ′@(.Γ₀) at .t)}
  (𝕣∗ , Rˢ~Rᶜ)
  ([Action] ([DEP-Destroy] {y = y} {Γ = Γ₀} {ds = ds}) refl) =
    -, -, -, step₁ Rˢ~Rᶜ
      ([R17⊣ {!!} ]
        mkℍ {mk {Γ₀}{y}{t}{ds} (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)}
            {!!} {!!})
-}
unparseMove
  {Rˢ@(record {end = Γₜ@(Γ at t)})}
  {Rᶜ}
  {delay⦅ δ ⦆}
  {Γₜ′@(Γ′@.Γ at .(t + δ))}
  (𝕣∗ , Rˢ~Rᶜ)
  ([Delay] δ&gt;0) =
    -, -, -, step₁ Rˢ~Rᶜ
      ([L18] mkℍ {mk {Γ} δ&gt;0 (Rᶜ ⨾ Rˢ ⨾ 𝕣∗ ⊣ refl , ↭-refl ≈ Γ′ ⊣ ↭-refl)})
-- ** unification errors for `C-Control` rules, T0D0: fording view
-- unparseMove {α = delay⦅ _ ⦆} _ ([Action] ([C-Control] _ _ _ ()) _)
-}</a>
<a id="unparseMoves"></a><a id="12249" href="SecureCompilation.Backtranslation.Unparsing.html#12249" class="Function">unparseMoves</a> <a id="12262" class="Symbol">:</a> <a id="12264" href="SymbolicModel.Run.Base.html#465" class="Generalizable">Rˢ</a> <a id="12267" href="Coherence.Relation.html#5522" class="Function Operator">~</a> <a id="12269" href="ComputationalModel.Run.html#4351" class="Generalizable">Rᶜ</a> <a id="12272" class="Symbol">→</a> <a id="12274" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="12279" class="Symbol">(</a><a id="12280" href="Data.Product.html#1378" class="Function">∃</a> <a id="12282" class="Symbol">λ</a> <a id="12284" href="SecureCompilation.Backtranslation.Unparsing.html#12284" class="Bound">α</a> <a id="12286" class="Symbol">→</a> <a id="12288" href="Data.Product.html#1378" class="Function">∃</a> <a id="12290" class="Symbol">(</a><a id="12291" href="SymbolicModel.Run.Base.html#465" class="Generalizable">Rˢ</a> <a id="12294" href="SymbolicModel.Run.Base.html#1301" class="Function Operator">——[</a> <a id="12298" href="SecureCompilation.Backtranslation.Unparsing.html#12284" class="Bound">α</a> <a id="12300" href="SymbolicModel.Run.Base.html#1301" class="Function Operator">]→_</a><a id="12303" class="Symbol">))</a> <a id="12306" class="Symbol">→</a> <a id="12308" href="ComputationalModel.Run.html#1329" class="Function">C.Labels</a>
<a id="12317" href="SecureCompilation.Backtranslation.Unparsing.html#12249" class="Function">unparseMoves</a> <a id="12330" href="SecureCompilation.Backtranslation.Unparsing.html#12330" class="Bound">Rˢ~Rᶜ</a> <a id="12336" class="Symbol">=</a> <a id="12338" href="Data.List.Base.html#1553" class="Function">map</a> <a id="12342" class="Symbol">λ</a> <a id="12344" class="Keyword">where</a>
  <a id="12352" class="Symbol">(</a><a id="12353" href="SecureCompilation.Backtranslation.Unparsing.html#12353" class="Bound">α</a> <a id="12355" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="12357" href="SecureCompilation.Backtranslation.Unparsing.html#12357" class="Bound">Γₜ</a> <a id="12360" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="12362" href="SecureCompilation.Backtranslation.Unparsing.html#12362" class="Bound">R→</a><a id="12364" class="Symbol">)</a> <a id="12366" class="Symbol">→</a> <a id="12368" href="SecureCompilation.Backtranslation.Unparsing.html#1168" class="Postulate">unparseMove</a> <a id="12380" href="SecureCompilation.Backtranslation.Unparsing.html#12330" class="Bound">Rˢ~Rᶜ</a> <a id="12386" href="SecureCompilation.Backtranslation.Unparsing.html#12362" class="Bound">R→</a> <a id="12389" class="Symbol">.</a><a id="12390" href="Agda.Builtin.Sigma.html#234" class="Field">proj₁</a>
</pre></body></html>